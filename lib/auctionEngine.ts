import { Auction, Bid, AIAgent, AuctionFormat } from '../types/auction'; export class AuctionEngine { private auctions: Map<string, Auction> = new Map(); private timers: Map<string, NodeJS.Timeout> = new Map(); private dutchTimers: Map<string, NodeJS.Timeout> = new Map(); createAuction(auction: Auction): void { this.auctions.set(auction.id, auction); } getAuction(id: string): Auction | undefined { return this.auctions.get(id); } getAllAuctions(): Auction[] { return Array.from(this.auctions.values()); } startAuction(auctionId: string, onUpdate: (auction: Auction) => void): void { const auction = this.auctions.get(auctionId); if (!auction) return; auction.status = 'active'; onUpdate(auction); if (auction.format === 'dutch') { this.startDutchAuction(auctionId, onUpdate); } const timer = setTimeout(() => { this.endAuction(auctionId, onUpdate); }, auction.endTime - Date.now()); this.timers.set(auctionId, timer); } private startDutchAuction(auctionId: string, onUpdate: (auction: Auction) => void): void { const auction = this.auctions.get(auctionId); if (!auction) return; const duration = auction.endTime - auction.startTime; const priceRange = auction.startingPrice - (auction.reservePrice || 0); const decrementInterval = 1000; const decrementAmount = (priceRange / duration) * decrementInterval; const timer = setInterval(() => { if (auction.status !== 'active') { clearInterval(timer); return; } auction.currentPrice = Math.max( auction.currentPrice - decrementAmount, auction.reservePrice || 0 ); onUpdate(auction); if (auction.currentPrice <= (auction.reservePrice || 0)) { this.endAuction(auctionId, onUpdate); clearInterval(timer); } }, decrementInterval); this.dutchTimers.set(auctionId, timer); } placeBid( auctionId: string, bid: Bid, onUpdate: (auction: Auction) => void ): { success: boolean; message: string } { const auction = this.auctions.get(auctionId); if (!auction) { return { success: false, message: 'Auction not found' }; } if (auction.status !== 'active') { return { success: false, message: 'Auction is not active' }; } const validation = this.validateBid(auction, bid); if (!validation.valid) { return { success: false, message: validation.message }; } if (auction.format === 'dutch') { auction.winnerId = bid.bidderId; auction.winnerType = bid.bidderType; auction.winnerName = bid.bidderName; auction.winningPrice = bid.amount; auction.bids.push(bid); this.endAuction(auctionId, onUpdate); return { success: true, message: 'Won the Dutch auction!' }; } auction.bids.push(bid); if (auction.format === 'english') { auction.currentPrice = bid.amount; } onUpdate(auction); return { success: true, message: 'Bid placed successfully' }; } private validateBid(auction: Auction, bid: Bid): { valid: boolean; message: string } { switch (auction.format) { case 'english': if (bid.amount < auction.currentPrice + auction.increment) { return { valid: false, message: Bid must be at least ${auction.currentPrice + auction.increment}, }; } break; case 'dutch': if (bid.amount < auction.currentPrice) { return { valid: false, message: Bid must be at least ${auction.currentPrice}, }; } break; case 'first_price_sealed': case 'vickrey': if (auction.bids.some((b) => b.bidderId === bid.bidderId)) { return { valid: false, message: 'You have already submitted a bid', }; } if (bid.amount < auction.startingPrice) { return { valid: false, message: Bid must be at least ${auction.startingPrice}, }; } break; } return { valid: true, message: '' }; } private endAuction(auctionId: string, onUpdate: (auction: Auction) => void): void { const auction = this.auctions.get(auctionId); if (!auction || auction.status !== 'active') return; auction.status = 'completed'; const timer = this.timers.get(auctionId); if (timer) { clearTimeout(timer); this.timers.delete(auctionId); } const dutchTimer = this.dutchTimers.get(auctionId); if (dutchTimer) { clearInterval(dutchTimer); this.dutchTimers.delete(auctionId); } this.determineWinner(auction); onUpdate(auction); } private determineWinner(auction: Auction): void { if (auction.bids.length === 0) return; switch (auction.format) { case 'english': const highestBid = auction.bids.reduce((max, bid) => bid.amount > max.amount ? bid : max ); auction.winnerId = highestBid.bidderId; auction.winnerType = highestBid.bidderType; auction.winnerName = highestBid.bidderName; auction.winningPrice = highestBid.amount; break; case 'dutch': break; case 'first_price_sealed': const highestSealed = auction.bids.reduce((max, bid) => bid.amount > max.amount ? bid : max ); if ( !auction.reservePrice || highestSealed.amount >= auction.reservePrice ) { auction.winnerId = highestSealed.bidderId; auction.winnerType = highestSealed.bidderType; auction.winnerName = highestSealed.bidderName; auction.winningPrice = highestSealed.amount; } break; case 'vickrey': const sortedBids = [...auction.bids].sort((a, b) => b.amount - a.amount); if (sortedBids.length > 0) { const winner = sortedBids[0]; const secondPrice = sortedBids.length > 1 ? sortedBids[1].amount : auction.startingPrice; if (!auction.reservePrice || secondPrice >= auction.reservePrice) { auction.winnerId = winner.bidderId; auction.winnerType = winner.bidderType; auction.winnerName = winner.bidderName; auction.winningPrice = secondPrice; } } break; } } joinAuction(auctionId: string, participantId: string): void { const auction = this.auctions.get(auctionId); if (auction) { auction.participants.add(participantId); } } cleanup(): void { this.timers.forEach((timer) => clearTimeout(timer)); this.dutchTimers.forEach((timer) => clearInterval(timer)); this.timers.clear(); this.dutchTimers.clear(); } }